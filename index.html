<!DOCTYPE html>
<html xmlns:v-on="http://www.w3.org/1999/xhtml">
<head>
    <title>Canvas</title>
    <link rel="stylesheet" type="text/css" href="bootstrap.css">
    <link rel="stylesheet" type="text/css" href="main.css">
    <style type="text/css">
        .canvas-element {
            position: absolute;
        }

        .canvas-element img,
        .canvas-element p {
            margin: 5px;
            padding: 5px;
            cursor: move;
            border: 1px dashed gray;
            display: inline-block;
        }

        .canvas .block {
            overflow: hidden;
        }

        .assets .image ul li img {
            cursor: pointer;
        }
    </style>
    <script type="text/javascript" src="https://unpkg.com/vue@latest/dist/vue.min.js"></script>
    <script type="text/javascript">
        function generateUID() {
            return 'element-' + (+new Date()) + '-' + Math.random()
                .toString(36)
                .substring(2);
        }

        function getElementOffsets(element) {
            return {
                width: element.offsetWidth,
                height: element.offsetHeight,
                top: element.offsetTop,
                left: element.offsetLeft,
                parent: element.offsetParent,
            };
        }

        function getSelectorsOffsets(selectors) {
            const element = document.querySelector(selectors);
            return getElementOffsets(element);
        }

        const store = {
            debug: false,
            state: {
                canvasBlockOffset: {
                    width: 600,
                    height: 600,
                    top: null,
                    left: null,
                    parent: null,
                },
                //Starting canvas elements' z-index from 1000
                upperMostElement: {
                    uid: null,
                    zIndex: 999,
                },
                canvasElements: [],
            },
            setCanvasBlockOffset(newValue) {
                if (this.debug) {
                    console.log('setCanvasBlockOffset:', 'before update:', JSON.stringify(this.state.canvasBlockOffset));
                    console.log('setCanvasBlockOffset:', 'triggered with:', JSON.stringify(newValue));
                }
                if ((typeof newValue === "object") && (newValue !== null)) {
                    this.state.canvasBlockOffset = newValue;
                }
                if (this.debug) {
                    console.log('setCanvasBlockOffset:', 'after update:', JSON.stringify(this.state.canvasBlockOffset));
                }
            },
            setUpperMostElement(newValue) {
                if (this.debug) {
                    console.log('setUpperMostElement:', 'before update:', JSON.stringify(this.state.upperMostElement));
                    console.log('setUpperMostElement:', 'triggered with:', JSON.stringify(newValue));
                }
                if ((typeof newValue === "object") && (newValue !== null)) {
                    this.state.upperMostElement = newValue;
                }
                if (this.debug) {
                    console.log('setUpperMostElement:', 'after update:', JSON.stringify(this.state.upperMostElement));
                }
            },
            setCanvasElements(newValue) {
                if (this.debug) {
                    console.log('setCanvasElements:', 'before update:', JSON.stringify(this.state.canvasElements));
                    console.log('setCanvasElements:', 'triggered with:', JSON.stringify(newValue));
                }
                if ((typeof newValue === "object") && (newValue !== null)) {
                    this.state.canvasElements = newValue;
                }
                if (this.debug) {
                    console.log('setCanvasElements:', 'after update:', JSON.stringify(this.state.canvasElements));
                }
            },
            addCanvasElement(newValue) {
                if (this.debug) {
                    console.log('addCanvasElement:', 'before update:', JSON.stringify(this.state.canvasElements));
                    console.log('addCanvasElement:', 'triggered with:', JSON.stringify(newValue));
                }
                if ((typeof newValue === "object") && (newValue !== null)) {
                    this.state.canvasElements.splice(0, 0, newValue);
                }
                if (this.debug) {
                    console.log('addCanvasElement:', 'after update:', JSON.stringify(this.state.canvasElements));
                }
            },
            updateCanvasElement(key, newValue) {
                if (this.debug)
                    console.log('updateCanvasElement:', 'triggered with:', JSON.stringify(key), JSON.stringify(newValue));
                if ((typeof newValue === "object") && (newValue !== null)) {
                    const indexOfItem = this.state.canvasElements.findIndex((element) => element.uid === key);
                    const value = this.state.canvasElements[indexOfItem];
                    if (this.debug)
                        console.log('updateCanvasElement:', 'before update:', JSON.stringify(this.state.canvasElements[indexOfItem]));
                    for (let key in newValue) {
                        if (!newValue.hasOwnProperty(key)) continue;
                        value[key] = newValue[key];
                    }
                    this.state.canvasElements.splice(indexOfItem, 1, value); // Update
                    if (this.debug)
                        console.log('updateCanvasElement:', 'after update:', JSON.stringify(this.state.canvasElements[indexOfItem]));
                }
            },
            deleteCanvasElement(key) {
                if (this.debug) {
                    console.log('deleteCanvasElement:', 'before update:', JSON.stringify(this.state.canvasElements[key]));
                    console.log('deleteCanvasElement:', 'triggered with:', JSON.stringify(key));
                }
                const indexOfItem = this.state.canvasElements.findIndex((element) => element.uid === key);
                this.state.canvasElements.splice(indexOfItem, 1); // Delete
                if (this.debug) {
                    console.log('deleteCanvasElement:', 'after update:', JSON.stringify(this.state.canvasElements[key]));
                }
            },
        };

        Vue.component('canvas-element', {
            props: [
                'element',
            ],
            data: {
                dragging: false,
                position: {
                    x: 0,
                    y: 0,
                },
            },
            methods: {
                eventStopPropagationPreventDefault: function (e) {
                },
                deleteElement: function (e) {
                    store.deleteCanvasElement(e.currentTarget.parentElement.id);
                },
                bringElementToFront: function (e) {
                    const element = store.state.canvasElements[e.currentTarget.id];
                    const upperMostElement = store.state.upperMostElement;
                    if (upperMostElement.uid === e.currentTarget.id) return;
                    store.setUpperMostElement({
                        uid: e.currentTarget.id,
                        zIndex: upperMostElement.zIndex + 1,
                    });
                    store.updateCanvasElement(e.currentTarget.id, {
                        zIndex: upperMostElement.zIndex + 1,
                    })
                },
                dragStart: function (e) {
                    this.dragging = true;

                    this.position = {
                        x: e.clientX,
                        y: e.clientY,
                    };
                },
                dragContinue: function (e) {
                    if (this.dragging) {
                        store.updateCanvasElement(e.currentTarget.id, {
                            position: {
                                top: e.currentTarget.offsetTop - (this.position.y - e.clientY),
                                left: e.currentTarget.offsetLeft - (this.position.x - e.clientX),
                            },
                        });
                        this.position = {
                            x: e.clientX,
                            y: e.clientY,
                        };
                    }
                },
                dragEnd: function (e) {
                    this.dragging = false;
                },
            },
            template: `
                <div
                :id="element.uid"
                v-on:click.prevent="bringElementToFront"
                v-on:mousedown.prevent="bringElementToFront"
                v-on:mousedown.prevent="dragStart"
                v-on:mousemove.prevent="dragContinue"
                v-on:mouseup.prevent="dragEnd"
                v-bind:class="[ 'canvas-element', element.text ? 'text' : 'image' ]"
                v-bind:style="{ zIndex: element.zIndex,
                top: element.position.top + 'px',
                left: element.position.left + 'px' }">
                    <button
                    type="button"
                    class="close"
                    v-on:click.stop.prevent="deleteElement"
                    v-on:mousedown.stop.prevent="eventStopPropagationPreventDefault"
                    >&times;</button>
                    <p v-if="element.text">{{ element.text }}</p>
                    <img v-else-if="element.src" :src="element.src" />
                </div>
`
        });

        window.onload = function () {
            new Vue({
                el: '#root',
                data: {
                    images: [],
                    sharedState: store.state,
                },
                created: function () {
                    this.setCanvasBlockOffset();
                    this.getImages();
                    this.getCanvasElements();
                },
                watch: {
                    sharedState: {
                        handler: function (newValue) {
                            // console.error(newValue)
                        },
                        deep: true
                    }
                },
                filters: {},
                methods: {
                    setCanvasBlockOffset: function () {
                        store.setCanvasBlockOffset(getSelectorsOffsets('.canvas .block'));
                    },
                    getImages: function () {
                        const xhr = new XMLHttpRequest();
                        const self = this;
                        xhr.open('GET', '/images');
                        xhr.onload = function () {
                            if (xhr.response) {
                                self.images = JSON.parse(xhr.response)
                            }
                        };
                        xhr.send();
                    },
                    postUploads: function (event) {
                        const input = document.querySelector('.form input[type=file]'),
                            file = input.files[0];

                        if (!file || !file.type.match(/image.*/)) return;

                        const data = new FormData();
                        data.append('upload', file);

                        const xhr = new XMLHttpRequest();
                        const self = this;
                        xhr.open('POST', '/uploads');
                        xhr.onloadend = function () {
                            if (xhr.response) {
                                const uploads = JSON.parse(xhr.response);
                                if (uploads) {
                                    self.images.push(uploads.file)
                                }
                            }
                        };
                        xhr.send(data);
                    },
                    getCanvasElements: function () {
                        store.setUpperMostElement(JSON.parse(localStorage.getItem('upperMostElement')));
                        const canvasElements = Object.keys(localStorage)
                            .reduce((obj, k) => {
                                if (!k.startsWith('element-')) return obj; // Matching the key signature
                                return {...obj, [k]: JSON.parse(localStorage.getItem(k))}
                            }, []);
                        store.setCanvasElements(canvasElements);
                    },
                    plotOnTheCanvas: function (e) {
                        const upperMostElement = store.state.upperMostElement;
                        const newZIndex = upperMostElement.zIndex + 1;
                        const uid = generateUID();
                        store.addCanvasElement({
                            uid,
                            position: {
                                top: 0,
                                left: 0,
                            },
                            zIndex: newZIndex,
                            src: e.target.src,
                        });
                        store.setUpperMostElement({
                            uid,
                            zIndex: newZIndex,
                        });
                    },
                }
            })
        };
    </script>
</head>
<body>
<div id="root">
    <!-- side pane -->
    <div class="sidepane col-sm-2 col-md-2 col-lg-2">
        <div class="form">
            <!-- Upload Form here -->
            <h3>Form</h3>
            <input type="file" class="form-control" placeholder="Upload Your Images" name="upload">
            <button id="submit" class="btn btn-default" v-on:click="postUploads">upload</button>
        </div>
        <hr/>
        <div class="assets">
            <h3>Assets</h3>
            <div class="text">
                <h4>Text</h4>
                <button id="addText" class="btn btn-default">Add Text</button>
            </div>
            <div class="image">
                <h4>Images</h4>
                <ul class="list-unstyled">
                    <!-- List of images here -->
                    <li
                            v-for="image in images"
                            :key="image"
                            v-on:click="plotOnTheCanvas"
                    >
                        <img :src="image" class="img-rounded"/>
                    </li>
                </ul>
            </div>
        </div>
    </div>
    <!-- canvas -->
    <div class="canvas col-sm-8 col-md-8 col-lg-8">
        <div class="block">
            <!-- Add images and texts to here -->
            <canvas-element
                    v-for="element in sharedState.canvasElements"
                    :key="element.uid"
                    :element="element"
            ></canvas-element>
        </div>
    </div>
</div>
</body>
</html>
